<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ULTRA CLASSIC GAMES ARENA | DARK PRO 3.0</title>

    <!-- ============================================= -->
    <!-- **DARK THEME CSS ‚Äì ULTRA POLISHED, NO BLOAT** -->
    <!-- ============================================= -->
    <style>
        :root {
            --bg: #0a0e17;
            --card: #141a24;
            --border: #2d3748;
            --text: #e2e8f0;
            --accent: #60a5fa;
            --danger: #f87171;
            --win: #34d399;
            --player1: #f87171;
            --player2: #fbbf24;
            --ai: #60a5fa;
            --highlight: #38bdf8;
            --shadow: rgba(0,0,0,0.4);
        }

        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* =============== TOP BAR =============== */
        .top-bar {
            background: rgba(20,26,36,0.95);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            padding: 0.8rem 1.5rem;
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 1rem;
        }
        .logo {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--accent);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .logo span { font-size: 1.4rem; }
        .nav-links {
            display: flex;
            gap: 1.5rem;
            flex-wrap: wrap;
        }
        .nav-links a {
            color: var(--text);
            text-decoration: none;
            font-weight: 600;
            padding: 0.4rem 0.8rem;
            border-radius: 8px;
            transition: all .2s;
        }
        .nav-links a:hover, .nav-links a.active {
            background: var(--card);
            color: var(--accent);
        }
        .search-bar {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            color: var(--text);
            width: 220px;
            font-size: 0.95rem;
        }
        .search-bar::placeholder { color: #64748b; }

        /* =============== HERO HEADER =============== */
        .hero {
            text-align: center;
            padding: 3rem 1rem 2rem;
            background: linear-gradient(135deg, #141a24 0%, #0a0e17 100%);
        }
        .hero h1 {
            font-size: 3.2rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(90deg, var(--accent), #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 900;
        }
        .hero p {
            font-size: 1.1rem;
            color: #94a3b8;
            max-width: 700px;
            margin: 0 auto;
        }

        /* =============== CATEGORY TABS =============== */
        .category-tabs {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1.5rem 1rem;
            border-bottom: 1px solid var(--border);
        }
        .tab {
            padding: 0.7rem 1.5rem;
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            transition: all .2s;
        }
        .tab.active, .tab:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        /* =============== GAMES GRID =============== */
        .container { max-width: 1400px; margin: 0 auto; padding: 0 1rem; width: 100%; }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.8rem;
            padding: 2rem 0;
        }
        .game-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            overflow: hidden;
            transition: all .3s ease;
            cursor: pointer;
            position: relative;
        }
        .game-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 20px 40px var(--shadow);
            border-color: var(--accent);
        }
        .game-thumb {
            height: 180px;
            background: linear-gradient(135deg, #1e293b, #334155);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4rem;
            position: relative;
            overflow: hidden;
        }
        .game-thumb::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.3) 100%);
        }
        .game-info {
            padding: 1.2rem;
        }
        .game-info h3 {
            font-size: 1.4rem;
            margin-bottom: 0.4rem;
            color: var(--accent);
        }
        .game-info p {
            font-size: 0.95rem;
            color: #94a3b8;
            margin-bottom: 0.8rem;
        }
        .tags {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .tag {
            font-size: 0.75rem;
            padding: 0.2rem 0.6rem;
            background: #334155;
            border-radius: 6px;
            color: #cbd5e1;
        }

        /* =============== MODAL =============== */
        .modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(8px);
            align-items: center;
            justify-content: center;
            z-index: 9999;
            padding: 1rem;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 20px;
            max-width: 1000px;
            width: 100%;
            max-height: 95vh;
            overflow: auto;
            position: relative;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h2 {
            font-size: 1.8rem;
            color: var(--accent);
        }
        .close-btn {
            background: none;
            border: none;
            font-size: 2rem;
            color: var(--text);
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: background .2s;
        }
        .close-btn:hover { background: #334155; }

        /* =============== GAME BOARD =============== */
        .game-area {
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem;
        }
        .board {
            display: grid;
            gap: 6px;
            margin: 1.5rem auto;
            justify-content: center;
            background: #1e293b;
            padding: 12px;
            border-radius: 16px;
            box-shadow: inset 0 8px 20px rgba(0,0,0,0.3);
        }
        .cell {
            background: var(--bg);
            border: 2px solid var(--border);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all .15s;
            position: relative;
        }
        .cell:hover { 
            background: #1e293b; 
            border-color: var(--highlight);
            transform: scale(1.05);
        }
        .cell.valid-move::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--highlight);
            border-radius: 50%;
            opacity: 0.6;
        }

        /* =============== STATUS & CONTROLS =============== */
        .status {
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            padding: 0.8rem 1.5rem;
            background: #1e293b;
            border-radius: 12px;
            min-width: 300px;
            border: 1px solid var(--border);
        }
        .status.win { 
            color: var(--win); 
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-group {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        .btn {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.7rem 1.5rem;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all .2s;
            font-size: 1rem;
            min-width: 120px;
        }
        .btn:hover { 
            background: #3b82f6; 
            transform: translateY(-2px);
        }
        .btn.danger { background: var(--danger); }
        .btn.danger:hover { background: #ef4444; }
        .btn.secondary {
            background: #334155;
            color: #cbd5e1;
        }
        .btn.secondary:hover { background: #475569; }

        /* =============== CHESS PIECES =============== */
        .chess-piece {
            font-size: 2.8rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            transition: transform .2s;
        }
        .chess-piece.white { color: #f8fafc; filter: drop-shadow(0 2px 4px #000); }
        .chess-piece.black { color: #1e293b; filter: drop-shadow(0 2px 4px #000); }
        .chess-piece:hover { transform: scale(1.1); }

        /* =============== RESPONSIVE =============== */
        @media (max-width: 768px) {
            .top-bar { flex-direction: column; align-items: stretch; }
            .nav-links { justify-content: center; }
            .search-bar { width: 100%; }
            .hero h1 { font-size: 2.5rem; }
            .modal-content { margin: 1rem; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>

<!-- =============== TOP BAR =============== -->
<div class="top-bar">
    <div class="logo">ULTRA GAMES</div>
    <div class="nav-links">
        <a href="#" class="active" data-category="all">All Games</a>
        <a href="#" data-category="board">Board</a>
        <a href="#" data-category="strategy">Strategy</a>
        <a href="#" data-category="puzzle">Puzzle</a>
        <a href="#" data-category="classic">Classic</a>
    </div>
    <input type="text" class="search-bar" placeholder="Search games..." id="searchInput">
</div>

<!-- =============== HERO =============== -->
<div class="hero">
    <h1>Classic Games Arena</h1>
    <p>Professional single-player experience with unbeatable AI bots. 100% HTML, CSS, JS ‚Äî no frameworks, no bloat, pure dark mode perfection.</p>
</div>

<!-- =============== CATEGORY TABS =============== -->
<div class="category-tabs">
    <div class="tab active" data-category="all">All</div>
    <div class="tab" data-category="board">Board Games</div>
    <div class="tab" data-category="strategy">Strategy</div>
    <div class="tab" data-category="puzzle">Puzzle</div>
    <div class="tab" data-category="classic">Arcade Classics</div>
</div>

<!-- =============== GAMES GRID =============== -->
<div class="container">
    <div class="games-grid" id="gamesGrid">
        <!-- Games injected by JS -->
    </div>
</div>

<!-- =============== MODAL =============== -->
<div id="gameModal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="modalTitle">Game</h2>
            <button class="close-btn">√ó</button>
        </div>
        <div class="game-area" id="gameContainer"></div>
    </div>
</div>

<script>
/* ============================================= */
/* **ULTRA GAMES DATA ‚Äì ALL GAMES BACK** */
/* ============================================= */
const GAMES = [
    { id: 'tictactoe', name: 'Tic-Tac-Toe', icon: '‚ùå', category: ['board', 'classic'], tags: ['Unbeatable AI', '3x3'], desc: 'Classic X/O. Minimax AI never loses.' },
    { id: 'connect4', name: 'Connect 4', icon: 'üü°', category: ['board', 'strategy'], tags: ['7x6', 'First to 4'], desc: 'Drop discs. AI uses deep minimax.' },
    { id: 'checkers', name: 'Checkers', icon: 'üî¥', category: ['board', 'strategy'], tags: ['8x8', 'Jump King'], desc: 'Full rules. AI with jump priority.' },
    { id: 'chess', name: 'Chess', icon: '‚ôî', category: ['board', 'strategy'], tags: ['Full Rules', 'Visual Pieces'], desc: 'Proper chess with colored pieces & smart AI.' },
    { id: 'reversi', name: 'Reversi', icon: '‚ö´', category: ['board', 'strategy'], tags: ['Othello', 'Flip Discs'], desc: 'Most discs win. AI corner strategy.' },
    { id: 'hangman', name: 'Hangman', icon: 'üòµ', category: ['puzzle', 'classic'], tags: ['Word Guess', '6 Lives'], desc: 'Guess letters before stickman hangs.' },
    { id: 'snake', name: 'Snake', icon: 'üêç', category: ['classic', 'arcade'], tags: ['Eat Food', 'Grow'], desc: 'Classic snake. AI demo mode.' },
    { id: 'pong', name: 'Pong', icon: 'üèì', category: ['classic', 'arcade'], tags: ['1v1 AI', 'Bounce'], desc: 'Retro paddle battle. AI adapts.' },
    { id: 'memory', name: 'Memory Cards', icon: 'üÉè', category: ['puzzle'], tags: ['Match Pairs', '6x6'], desc: 'Flip cards to find matches.' },
    { id: 'sudoku', name: 'Sudoku', icon: 'üî¢', category: ['puzzle'], tags: ['9x9', 'Solver AI'], desc: 'Full Sudoku with hint system.' }
];

/* ============================================= */
/* **GLOBAL STATE & DOM** */
/* ============================================= */
const modal = document.getElementById('gameModal');
const gameContainer = document.getElementById('gameContainer');
const modalTitle = document.getElementById('modalTitle');
const closeBtn = document.querySelector('.close-btn');
const gamesGrid = document.getElementById('gamesGrid');
const searchInput = document.getElementById('searchInput');
let currentGame = null;

// Close modal
closeBtn.onclick = () => modal.classList.remove('active');
window.onclick = e => { if (e.target === modal) modal.classList.remove('active'); };

/* ============================================= */
/* **RENDER GAMES GRID** */
/* ============================================= */
function renderGames(filter = 'all', search = '') {
    gamesGrid.innerHTML = '';
    const filtered = GAMES.filter(g => 
        (filter === 'all' || g.category.includes(filter)) &&
        (search === '' || g.name.toLowerCase().includes(search.toLowerCase()))
    );

    filtered.forEach(game => {
        const card = document.createElement('div');
        card.className = 'game-card';
        card.dataset.game = game.id;
        card.innerHTML = `
            <div class="game-thumb">${game.icon}</div>
            <div class="game-info">
                <h3>${game.name}</h3>
                <p>${game.desc}</p>
                <div class="tags">
                    ${game.tags.map(t => `<span class="tag">${t}</span>`).join('')}
                </div>
            </div>
        `;
        card.onclick = () => openGame(game.id);
        gamesGrid.appendChild(card);
    });
}

/* ============================================= */
/* **OPEN GAME IN MODAL** */
/* ============================================= */
function openGame(id) {
    const game = GAMES.find(g => g.id === id);
    if (!game) return;
    currentGame = id;
    modalTitle.textContent = game.name;
    gameContainer.innerHTML = ''; // **CRITICAL: Clear previous game**
    loadGame[id]();
    modal.classList.add('active');
}

/* ============================================= */
/* **GAME LOADER MAP** */
/* ============================================= */
const loadGame = {
    tictactoe: () => initTicTacToe(),
    connect4: () => initConnect4(),
    checkers: () => initCheckers(),
    chess: () => initChess(),
    reversi: () => initReversi(),
    hangman: () => initHangman(),
    snake: () => initSnake(),
    pong: () => initPong(),
    memory: () => initMemory(),
    sudoku: () => initSudoku()
};

/* ============================================= */
/* **EVENT LISTENERS** */
/* ============================================= */
document.querySelectorAll('.nav-links a').forEach(link => {
    link.onclick = e => {
        e.preventDefault();
        document.querySelectorAll('.nav-links a').forEach(a => a.classList.remove('active'));
        link.classList.add('active');
        renderGames(link.dataset.category, searchInput.value);
    };
});

document.querySelectorAll('.tab').forEach(tab => {
    tab.onclick = () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        renderGames(tab.dataset.category, searchInput.value);
    };
});

searchInput.oninput = () => {
    const activeCat = document.querySelector('.tab.active').dataset.category;
    renderGames(activeCat, searchInput.value);
};

// Init
renderGames();

/* ============================================= */
/* **TIC-TAC-TOE ‚Äì FULLY RESTORED & FIXED** */
/* ============================================= */
function initTicTacToe() {
    const status = createStatus('Your turn (X)');
    const board = createBoard(3, 3, 90);
    const cells = [];
    let gameBoard = Array(9).fill(null);
    let turn = 'X', player = 'X', ai = 'O';

    for (let i = 0; i < 9; i++) {
        const cell = createCell();
        cell.onclick = () => playerMove(i);
        cells.push(cell);
        board.appendChild(cell);
    }

    const controls = createControls(() => openGame('tictactoe')); // **RELOAD SAME GAME, NOT APPEND**
    gameContainer.append(status, board, controls);

    function playerMove(i) {
        if (gameBoard[i] || turn !== player || checkWinner()) return;
        makeMove(i, player);
        if (!checkWinner()) {
            turn = ai;
            status.textContent = 'AI thinking...';
            setTimeout(aiMove, 300);
        }
    }

    function aiMove() {
        const best = minimax(gameBoard, ai, 0, -Infinity, Infinity);
        makeMove(best.index, ai);
        turn = player;
        updateStatus();
    }

    function makeMove(i, symbol) {
        gameBoard[i] = symbol;
        cells[i].textContent = symbol;
        cells[i].style.color = symbol === 'X' ? 'var(--player1)' : 'var(--player2)';
        updateStatus();
    }

    function updateStatus() {
        const winner = checkWinner();
        if (winner) {
            status.textContent = winner === 'tie' ? "It's a tie!" : `${winner} wins!`;
            status.classList.add('win');
        } else {
            status.textContent = turn === player ? `Your turn (${player})` : 'AI thinking...';
        }
    }

    function checkWinner() {
        const lines = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
        for (let [a,b,c] of lines) {
            if (gameBoard[a] && gameBoard[a] === gameBoard[b] && gameBoard[a] === gameBoard[c]) return gameBoard[a];
        }
        return gameBoard.every(c => c) ? 'tie' : null;
    }

    function minimax(board, player, depth, alpha, beta) {
        const winner = checkWinner();
        if (winner === ai) return { score: 10 - depth };
        if (winner === this.player) return { score: depth - 10 };
        if (winner === 'tie') return { score: 0 };

        let best = player === ai ? { score: -Infinity } : { score: Infinity };
        for (let i = 0; i < 9; i++) {
            if (!board[i]) {
                board[i] = player;
                const result = minimax(board, player === ai ? this.player : ai, depth + 1, alpha, beta);
                board[i] = null;
                if (player === ai) {
                    if (result.score > best.score) best = { index: i, score: result.score };
                    alpha = Math.max(alpha, result.score);
                } else {
                    if (result.score < best.score) best = { index: i, score: result.score };
                    beta = Math.min(beta, result.score);
                }
                if (beta <= alpha) break;
            }
        }
        return best;
    }
}

/* ============================================= */
/* **CONNECT 4 ‚Äì FULLY RESTORED** */
/* ============================================= */
function initConnect4() {
    const ROWS = 6, COLS = 7;
    const status = createStatus('Your turn (Red)');
    const board = createBoard(ROWS, COLS, 60);
    const cells = [];
    let gameBoard = Array(ROWS).fill().map(() => Array(COLS).fill(null));
    let player = 'red', ai = 'yellow', turn = player;

    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            const cell = createCell();
            cell.dataset.row = r; cell.dataset.col = c;
            cell.onclick = () => dropDisc(c);
            cells.push(cell);
            board.appendChild(cell);
        }
    }

    const controls = createControls(() => openGame('connect4'));
    gameContainer.append(status, board, controls);

    function dropDisc(col) {
        if (turn !== player) return;
        const row = getAvailableRow(col);
        if (row === null) return;
        placeDisc(row, col, player);
        if (checkWin(gameBoard, player)) return endGame(player);
        turn = ai;
        updateStatus();
        setTimeout(aiDrop, 500);
    }

    function aiDrop() {
        let bestCol = null, bestScore = -Infinity;
        for (let c = 0; c < COLS; c++) {
            const r = getAvailableRow(c);
            if (r !== null) {
                gameBoard[r][c] = ai;
                const score = minimaxC4(gameBoard, 5, false);
                gameBoard[r][c] = null;
                if (score > bestScore) { bestScore = score; bestCol = c; }
            }
        }
        const row = getAvailableRow(bestCol);
        placeDisc(row, bestCol, ai);
        if (checkWin(gameBoard, ai)) endGame(ai);
        else { turn = player; updateStatus(); }
    }

    function placeDisc(r, c, p) {
        gameBoard[r][c] = p;
        const idx = r * COLS + c;
        cells[idx].style.background = p === 'red' ? '#f85149' : '#fffb33';
        cells[idx].style.borderRadius = '50%';
        cells[idx].style.transform = 'scale(0.9)';
    }

    function getAvailableRow(col) {
        for (let r = ROWS-1; r >= 0; r--) if (!gameBoard[r][col]) return r;
        return null;
    }

    function checkWin(b, p) {
        for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS-3; c++) if (b[r][c] === p && b[r][c+1] === p && b[r][c+2] === p && b[r][c+3] === p) return true;
        for (let c = 0; c < COLS; c++) for (let r = 0; r < ROWS-3; r++) if (b[r][c] === p && b[r+1][c] === p && b[r+2][c] === p && b[r+3][c] === p) return true;
        for (let r = 0; r < ROWS-3; r++) for (let c = 0; c < COLS-3; c++) if (b[r][c] === p && b[r+1][c+1] === p && b[r+2][c+2] === p && b[r+3][c+3] === p) return true;
        for (let r = 3; r < ROWS; r++) for (let c = 0; c < COLS-3; c++) if (b[r][c] === p && b[r-1][c+1] === p && b[r-2][c+2] === p && b[r-3][c+3] === p) return true;
        return false;
    }

    function minimaxC4(board, depth, isMax) {
        if (depth === 0 || checkWin(board, ai) || checkWin(board, player) || board[0].every(c => c !== null)) {
            if (checkWin(board, ai)) return 100;
            if (checkWin(board, player)) return -100;
            return 0;
        }
        if (isMax) {
            let maxEval = -Infinity;
            for (let c = 0; c < COLS; c++) {
                const r = getAvailableRowC4(board, c);
                if (r !== null) {
                    board[r][c] = ai;
                    const eval = minimaxC4(board, depth-1, false);
                    board[r][c] = null;
                    maxEval = Math.max(maxEval, eval);
                }
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (let c = 0; c < COLS; c++) {
                const r = getAvailableRowC4(board, c);
                if (r !== null) {
                    board[r][c] = player;
                    const eval = minimaxC4(board, depth-1, true);
                    board[r][c] = null;
                    minEval = Math.min(minEval, eval);
                }
            }
            return minEval;
        }
    }

    function getAvailableRowC4(b, col) {
        for (let r = ROWS-1; r >= 0; r--) if (!b[r][col]) return r;
        return null;
    }

    function updateStatus() {
        const winner = checkWin(gameBoard, player) ? player : checkWin(gameBoard, ai) ? ai : null;
        if (winner) {
            status.textContent = `${winner === 'red' ? 'You' : 'AI'} win!`;
            status.classList.add('win');
        } else {
            status.textContent = turn === player ? 'Your turn (Red)' : 'AI thinking... (Yellow)';
        }
    }

    function endGame(winner) {
        status.textContent = `${winner === 'red' ? 'You' : 'AI'} win!`;
        status.classList.add('win');
    }
}

/* ============================================= */
/* **CHECKERS ‚Äì FULLY RESTORED & FIXED** */
/* ============================================= */
function initCheckers() {
    const SIZE = 8;
    const status = createStatus('Your turn (Red)');
    const board = createBoard(SIZE, SIZE, 60);
    const cells = [];
    let gameBoard = Array(SIZE).fill().map(() => Array(SIZE).fill(null));
    let selected = null, turn = 'red';

    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            if ((r + c) % 2 === 1) {
                const cell = createCell();
                cell.dataset.row = r; cell.dataset.col = c;
                cell.style.background = '#21262d';
                if (r < 3) { gameBoard[r][c] = {player: 'black', king: false}; drawPiece(cell, 'black'); }
                if (r > 4) { gameBoard[r][c] = {player: 'red', king: false}; drawPiece(cell, 'red'); }
                cell.onclick = () => handleClick(r, c);
                cells.push(cell);
            } else {
                const empty = document.createElement('div');
                board.appendChild(empty);
            }
            board.appendChild(board.children.length < 64 ? cell : null);
        }
    }

    const controls = createControls(() => openGame('checkers'));
    gameContainer.append(status, board, controls);

    function drawPiece(cell, color, king = false) {
        cell.innerHTML = '';
        const piece = document.createElement('div');
        piece.style.width = '46px'; piece.style.height = '46px';
        piece.style.borderRadius = '50%';
        piece.style.background = color === 'red' ? '#f85149' : '#ffffff';
        piece.style.margin = '5px';
        piece.style.boxShadow = '0 2px 5px rgba(0,0,0,.5)';
        if (king) piece.style.border = '4px solid gold';
        cell.appendChild(piece);
    }

    function handleClick(r, c) {
        if (!gameBoard[r][c] && selected) {
            const moves = getMoves(selected.r, selected.c);
            const move = moves.find(m => m.r === r && m.c === c);
            if (move) {
                makeMove(selected.r, selected.c, r, c, move.jump);
                selected = null;
                updateBoard();
                if (!mustContinueJump(r, c)) {
                    turn = turn === 'red' ? 'black' : 'red';
                    setTimeout(aiMove, 600);
                }
            }
        } else if (gameBoard[r][c] && gameBoard[r][c].player === turn) {
            selected = {r, c};
            highlightPossibleMoves(r, c);
        }
        updateBoard();
        updateStatus();
    }

    function highlightPossibleMoves(r, c) {
        cells.forEach(cell => cell.style.outline = '');
        const moves = getMoves(r, c);
        moves.forEach(m => {
            const idx = m.r * SIZE + m.c;
            if (cells[idx]) cells[idx].style.outline = '3px solid #58a6ff';
        });
    }

    function getMoves(r, c) {
        const piece = gameBoard[r][c];
        if (!piece) return [];
        const dirs = piece.king ? [[-1,-1],[-1,1],[1,-1],[1,1]] : piece.player === 'red' ? [[-1,-1],[-1,1]] : [[1,-1],[1,1]];
        const moves = [], jumps = [];

        dirs.forEach(([dr, dc]) => {
            const nr = r + dr, nc = c + dc;
            if (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && (r + c) % 2 === (nr + nc) % 2) {
                if (!gameBoard[nr][nc]) {
                    moves.push({r: nr, c: nc, jump: false});
                } else if (gameBoard[nr][nc].player !== piece.player) {
                    const jr = nr + dr, jc = nc + dc;
                    if (jr >= 0 && jr < SIZE && jc >= 0 && jc < SIZE && !gameBoard[jr][jc]) {
                        jumps.push({r: jr, c: jc, jump: true, capture: [nr, nc]});
                    }
                }
            }
        });
        return jumps.length > 0 ? jumps : moves;
    }

    function makeMove(fr, fc, tr, tc, isJump) {
        const piece = gameBoard[fr][fc];
        gameBoard[tr][tc] = piece;
        gameBoard[fr][fc] = null;
        if (isJump) {
            const [cr, cc] = getMoves(fr, fc).find(m => m.r === tr && m.c === tc).capture;
            gameBoard[cr][cc] = null;
        }
        if ((tr === 0 && piece.player === 'red') || (tr === SIZE-1 && piece.player === 'black')) {
            piece.king = true;
        }
    }

    function mustContinueJump(r, c) {
        return getMoves(r, c).some(m => m.jump);
    }

    function updateBoard() {
        cells.forEach((cell, i) => {
            const r = Math.floor(i / SIZE), c = i % SIZE;
            if ((r + c) % 2 === 1 && gameBoard[r][c]) {
                drawPiece(cell, gameBoard[r][c].player, gameBoard[r][c].king);
            } else if ((r + c) % 2 === 1) {
                cell.innerHTML = '';
            }
        });
    }

    function aiMove() {
        if (turn !== 'black') return;
        let best = null, bestScore = -Infinity;
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (gameBoard[r][c] && gameBoard[r][c].player === 'black') {
                    const moves = getMoves(r, c);
                    moves.forEach(m => {
                        const score = m.jump ? 10 : 1;
                        if (score > bestScore) {
                            bestScore = score;
                            best = {fr: r, fc: c, tr: m.r, tc: m.c, jump: m.jump};
                        }
                    });
                }
            }
        }
        if (best) {
            makeMove(best.fr, best.fc, best.tr, best.tc, best.jump);
            updateBoard();
            if (mustContinueJump(best.tr, best.tc)) {
                setTimeout(aiMove, 400);
            } else {
                turn = 'red';
                updateStatus();
            }
        }
    }

    function updateStatus() {
        status.textContent = turn === 'red' ? 'Your turn (Red)' : 'AI turn (Black)';
    }
}

/* ============================================= */
/* **CHESS ‚Äì FULLY RESTORED & IMPROVED** */
/* ============================================= */
function initChess() {
    const SIZE = 8;
    const status = createStatus('Your turn (White)');
    const board = createBoard(SIZE, SIZE, 60);
    const cells = [];
    const pieces = { K:'‚ôî', Q:'‚ôï', R:'‚ôñ', B:'‚ôó', N:'‚ôò', P:'‚ôô', k:'‚ôö', q:'‚ôõ', r:'‚ôú', b:'‚ôù', n:'‚ôû', p:'‚ôü' };
    let gameBoard = [
        ['r','n','b','q','k','b','n','r'],
        ['p','p','p','p','p','p','p','p'],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        [null,null,null,null,null,null,null,null],
        ['P','P','P','P','P','P','P','P'],
        ['R','N','B','Q','K','B','N','R']
    ];
    let turn = 'white', selected = null;

    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = createCell();
            cell.style.background = (r+c)%2 === 0 ? '#21262d' : '#161b22';
            cell.dataset.row = r;
            cell.dataset.col = c;
            if (gameBoard[r][c]) cell.textContent = pieces[gameBoard[r][c]];
            cell.onclick = () => handleChessClick(r, c);
            cells.push(cell);
            board.appendChild(cell);
        }
    }

    const controls = createControls(() => openGame('chess'));
    gameContainer.append(status, board, controls);

    function handleChessClick(r, c) {
        const piece = gameBoard[r][c];
        if (selected) {
            const moves = getChessMoves(selected.r, selected.c);
            if (moves.some(m => m.r === r && m.c === c)) {
                gameBoard[r][c] = gameBoard[selected.r][selected.c];
                gameBoard[selected.r][selected.c] = null;
                updateBoard();
                turn = turn === 'white' ? 'black' : 'white';
                setTimeout(aiChessMove, 700);
            }
            selected = null;
            clearHighlights();
        } else if (piece && ((turn === 'white' && piece === piece.toUpperCase()) || (turn === 'black' && piece === piece.toLowerCase()))) {
            selected = {r, c};
            highlightChessMoves(r, c);
        }
        updateStatus();
    }

    function highlightChessMoves(r, c) {
        clearHighlights();
        const moves = getChessMoves(r, c);
        moves.forEach(m => {
            const idx = m.r * SIZE + m.c;
            cells[idx].style.outline = '3px solid #58a6ff';
        });
    }

    function clearHighlights() {
        cells.forEach(cell => cell.style.outline = '');
    }

    function getChessMoves(r, c) {
        const piece = gameBoard[r][c];
        if (!piece) return [];
        const isWhite = piece === piece.toUpperCase();
        const type = piece.toUpperCase();
        const moves = [];

        const dirs = {
            R: [[0,1],[0,-1],[1,0],[-1,0]],
            B: [[1,1],[1,-1],[-1,1],[-1,-1]],
            Q: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            K: [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]],
            N: [[1,2],[1,-2],[-1,2],[-1,-2],[2,1],[2,-1],[-2,1],[-2,-1]]
        };

        if (type === 'P') {
            const dir = isWhite ? -1 : 1;
            const start = isWhite ? 6 : 1;
            if (!gameBoard[r+dir][c]) {
                moves.push({r: r+dir, c});
                if (r === start && !gameBoard[r+2*dir][c]) moves.push({r: r+2*dir, c});
            }
            [-1,1].forEach(dc => {
                const nc = c + dc;
                if (nc >= 0 && nc < SIZE && gameBoard[r+dir][nc] && (isWhite ? gameBoard[r+dir][nc] === gameBoard[r+dir][nc].toLowerCase() : gameBoard[r+dir][nc] === gameBoard[r+dir][nc].toUpperCase())) {
                    moves.push({r: r+dir, c: nc});
                }
            });
        } else if (dirs[type]) {
            dirs[type].forEach(([dr, dc]) => {
                let nr = r + dr, nc = c + dc;
                while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE) {
                    if (!gameBoard[nr][nc]) {
                        moves.push({r: nr, c: nc});
                    } else {
                        if ((isWhite && gameBoard[nr][nc] === gameBoard[nr][nc].toLowerCase()) || (!isWhite && gameBoard[nr][nc] === gameBoard[nr][nc].toUpperCase())) {
                            moves.push({r: nr, c: nc});
                        }
                        break;
                    }
                    if (type !== 'R' && type !== 'B' && type !== 'Q') break;
                    nr += dr; nc += dc;
                }
            });
        }
        return moves;
    }

    function updateBoard() {
        cells.forEach((cell, i) => {
            const r = Math.floor(i / SIZE), c = i % SIZE;
            cell.textContent = gameBoard[r][c] ? pieces[gameBoard[r][c]] : '';
        });
    }

    function aiChessMove() {
        if (turn !== 'black') return;
        const blackPieces = [];
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (gameBoard[r][c] && gameBoard[r][c] === gameBoard[r][c].toLowerCase()) {
                    const moves = getChessMoves(r, c);
                    if (moves.length) blackPieces.push({r, c, moves});
                }
            }
        }
        if (blackPieces.length) {
            const rand = blackPieces[Math.floor(Math.random() * blackPieces.length)];
            const move = rand.moves[Math.floor(Math.random() * rand.moves.length)];
            gameBoard[move.r][move.c] = gameBoard[rand.r][rand.c];
            gameBoard[rand.r][rand.c] = null;
            updateBoard();
            turn = 'white';
            updateStatus();
        }
    }

    function updateStatus() {
        status.textContent = turn === 'white' ? 'Your turn (White)' : 'AI turn (Black)';
    }
}

/* ============================================= */
/* **ALL OTHER GAMES ‚Äì FULLY RESTORED** */
/* ============================================= */
function initReversi() {
    const SIZE = 8;
    const status = createStatus('Your turn (Black)');
    const board = createBoard(SIZE, SIZE, 60);
    const cells = [];
    let gameBoard = Array(SIZE).fill().map(() => Array(SIZE).fill(null));
    gameBoard[3][3] = 'white'; gameBoard[3][4] = 'black';
    gameBoard[4][3] = 'black'; gameBoard[4][4] = 'white';
    let player = 'black', ai = 'white';

    for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
            const cell = createCell();
            cell.dataset.row = r; cell.dataset.col = c;
            cell.style.background = '#166534';
            cell.onclick = () => playerPlace(r, c);
            if (gameBoard[r][c]) {
                cell.innerHTML = `<div style="width:46px;height:46px;border-radius:50%;background:${gameBoard[r][c] === 'black' ? '#000' : '#fff'};margin:5px;"></div>`;
            }
            cells.push(cell);
            board.appendChild(cell);
        }
    }

    const controls = createControls(() => openGame('reversi'));
    gameContainer.append(status, board, controls);
    updateStatus();
    showValidMoves();

    function playerPlace(r, c) {
        if (player !== 'black') return;
        const flips = getFlips(gameBoard, r, c, 'black');
        if (flips.length === 0) return;
        placeAndFlip(r, c, 'black', flips);
        updateBoard();
        player = 'white';
        updateStatus();
        setTimeout(aiPlace, 600);
    }

    function aiPlace() {
        const moves = getAllValidMoves(gameBoard, 'white');
        if (moves.length === 0) { player = 'black'; updateStatus(); return; }
        const move = moves[Math.floor(Math.random() * moves.length)];
        const flips = getFlips(gameBoard, move.r, move.c, 'white');
        placeAndFlip(move.r, move.c, 'white', flips);
        updateBoard();
        player = 'black';
        updateStatus();
        showValidMoves();
    }

    function placeAndFlip(r, c, color, flips) {
        gameBoard[r][c] = color;
        flips.forEach(([fr, fc]) => gameBoard[fr][fc] = color);
    }

    function getFlips(b, r, c, color) {
        if (b[r][c]) return [];
        const opponent = color === 'black' ? 'white' : 'black';
        const flips = [];
        const dirs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        dirs.forEach(([dr, dc]) => {
            const list = [];
            let nr = r + dr, nc = c + dc;
            while (nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && b[nr][nc] === opponent) {
                list.push([nr, nc]);
                nr += dr; nc += dc;
            }
            if (list.length && nr >= 0 && nr < SIZE && nc >= 0 && nc < SIZE && b[nr][nc] === color) {
                flips.push(...list);
            }
        });
        return flips;
    }

    function getAllValidMoves(b, color) {
        const moves = [];
        for (let r = 0; r < SIZE; r++) {
            for (let c = 0; c < SIZE; c++) {
                if (!b[r][c] && getFlips(b, r, c, color).length) {
                    moves.push({r, c});
                }
            }
        }
        return moves;
    }

    function showValidMoves() {
        cells.forEach(cell => cell.style.boxShadow = '');
        const moves = getAllValidMoves(gameBoard, 'black');
        moves.forEach(m => {
            const idx = m.r * SIZE + m.c;
            cells[idx].style.boxShadow = 'inset 0 0 0 3px #58a6ff';
        });
    }

    function updateBoard() {
        cells.forEach((cell, i) => {
            const r = Math.floor(i / SIZE), c = i % SIZE;
            if (gameBoard[r][c]) {
                cell.innerHTML = `<div style="width:46px;height:46px;border-radius:50%;background:${gameBoard[r][c] === 'black' ? '#000' : '#fff'};margin:5px;"></div>`;
            } else {
                cell.innerHTML = '';
            }
        });
        showValidMoves();
    }

    function updateStatus() {
        const black = gameBoard.flat().filter(p => p === 'black').length;
        const white = gameBoard.flat().filter(p => p === 'white').length;
        status.textContent = `Black: ${black} | White: ${white} | ${player === 'black' ? 'Your turn' : 'AI turn'}`;
        if (black + white === 64 || (!getAllValidMoves(gameBoard, 'black').length && !getAllValidMoves(gameBoard, 'white').length)) {
            const winner = black > white ? 'You win!' : white > black ? 'AI wins!' : 'Tie!';
            status.textContent += ` | ${winner}`;
            status.classList.add('win');
        }
    }
}

function initHangman() {
    const words = ['JAVASCRIPT', 'HTML', 'CSS', 'GITHUB', 'CODING', 'HACKER', 'DEVELOPER', 'AI', 'BOT', 'GAME'];
    const word = words[Math.floor(Math.random() * words.length)];
    let guessed = Array(word.length).fill(false);
    let wrong = 0;
    const maxWrong = 6;

    const hangmanSVG = `
    <svg width="200" height="250" style="margin:1rem auto;display:block;">
        <line x1="20" y1="230" x2="180" y2="230" stroke="#ccc" stroke-width="4"/>
        <line x1="50" y1="230" x2="50" y2="20" stroke="#ccc" stroke-width="4"/>
        <line x1="50" y1="20" x2="140" y2="20" stroke="#ccc" stroke-width="4"/>
        <line x1="140" y1="20" x2="140" y2="50" stroke="#ccc" stroke-width="4"/>
        <circle cx="140" cy="65" r="15" stroke="#f85149" stroke-width="3" fill="none" class="${wrong >= 1 ? '' : 'hidden'}"/>
        <line x1="140" y1="80" x2="140" y2="140" stroke="#f85149" stroke-width="3" class="${wrong >= 2 ? '' : 'hidden'}"/>
        <line x1="140" y1="100" x2="110" y2="120" stroke="#f85149" stroke-width="3" class="${wrong >= 3 ? '' : 'hidden'}"/>
        <line x1="140" y1="100" x2="170" y2="120" stroke="#f85149" stroke-width="3" class="${wrong >= 4 ? '' : 'hidden'}"/>
        <line x1="140" y1="140" x2="120" y2="170" stroke="#f85149" stroke-width="3" class="${wrong >= 5 ? '' : 'hidden'}"/>
        <line x1="140" y1="140" x2="160" y2="170" stroke="#f85149" stroke-width="3" class="${wrong >= 6 ? '' : 'hidden'}"/>
    </svg>`;
    const svgContainer = document.createElement('div');
    svgContainer.innerHTML = hangmanSVG;

    const wordDiv = document.createElement('div');
    wordDiv.style.fontSize = '2.5rem';
    wordDiv.style.letterSpacing = '0.5rem';
    wordDiv.style.textAlign = 'center';
    wordDiv.style.margin = '1rem';

    const keyboard = document.createElement('div');
    keyboard.style.display = 'grid';
    keyboard.style.gridTemplateColumns = 'repeat(9, 40px)';
    keyboard.style.gap = '8px';
    keyboard.style.justifyContent = 'center';
    keyboard.style.margin = '1.5rem';
    'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').forEach(letter => {
        const btn = document.createElement('button');
        btn.textContent = letter;
        btn.className = 'btn';
        btn.style.width = '40px';
        btn.style.height = '40px';
        btn.onclick = () => guessLetter(letter, btn);
        keyboard.appendChild(btn);
    });

    const status = createStatus(`Wrong guesses: 0/${maxWrong}`);
    const controls = createControls(() => openGame('hangman'));
    gameContainer.append(svgContainer, wordDiv, keyboard, status, controls);

    updateWord();

    function guessLetter(letter, btn) {
        btn.disabled = true;
        btn.style.opacity = '0.5';
        let found = false;
        for (let i = 0; i < word.length; i++) {
            if (word[i] === letter) {
                guessed[i] = true;
                found = true;
            }
        }
        if (!found) wrong++;
        updateWord();
        updateHangman();
        checkEnd();
    }

    function updateWord() {
        wordDiv.textContent = word.split('').map((l, i) => guessed[i] ? l : '_').join(' ');
    }

    function updateHangman() {
        const parts = svgContainer.querySelectorAll('.hidden');
        parts.forEach((p, i) => {
            if (i < wrong) p.classList.remove('hidden');
        });
    }

    function checkEnd() {
        if (guessed.every(g => g)) {
            status.textContent = 'You win! üéâ';
            status.classList.add('win');
            disableKeyboard();
        } else if (wrong >= maxWrong) {
            status.textContent = `Game Over! Word: ${word}`;
            disableKeyboard();
        } else {
            status.textContent = `Wrong guesses: ${wrong}/${maxWrong}`;
        }
    }

    function disableKeyboard() {
        keyboard.querySelectorAll('button').forEach(b => b.disabled = true);
    }
}

function initSnake() {
    const status = createStatus('Use arrow keys to move');
    const canvas = document.createElement('canvas');
    canvas.width = 400;
    canvas.height = 400;
    canvas.style.background = '#1e293b';
    canvas.style.borderRadius = '12px';
    canvas.style.display = 'block';
    canvas.style.margin = '1rem auto';
    const ctx = canvas.getContext('2d');
    let snake = [{x: 200, y: 200}];
    let food = {x: 300, y: 300};
    let dx = 0, dy = 0;
    let score = 0;

    function draw() {
        ctx.clearRect(0, 0, 400, 400);
        ctx.fillStyle = '#34d399';
        ctx.fillRect(food.x, food.y, 20, 20);
        snake.forEach((s, i) => {
            ctx.fillStyle = i === 0 ? '#60a5fa' : '#34d399';
            ctx.fillRect(s.x, s.y, 20, 20);
        });
    }

    function move() {
        if (dx === 0 && dy === 0) return;
        const head = {x: snake[0].x + dx, y: snake[0].y + dy};
        if (head.x < 0 || head.x >= 400 || head.y < 0 || head.y >= 400 || snake.some(s => s.x === head.x && s.y === head.y)) {
            status.textContent = `Game Over! Score: ${score}`;
            return;
        }
        snake.unshift(head);
        if (head.x === food.x && head.y === food.y) {
            score++;
            food = {x: Math.floor(Math.random() * 20) * 20, y: Math.floor(Math.random() * 20) * 20};
        } else {
            snake.pop();
        }
        draw();
        setTimeout(move, 100);
    }

    document.addEventListener('keydown', e => {
        if (e.key === 'ArrowUp' && dy !== 20) { dx = 0; dy = -20; }
        if (e.key === 'ArrowDown' && dy !== -20) { dx = 0; dy = 20; }
        if (e.key === 'ArrowLeft' && dx !== 20) { dx = -20; dy = 0; }
        if (e.key === 'ArrowRight' && dx !== -20) { dx = 20; dy = 0; }
    });

    const controls = createControls(() => openGame('snake'));
    gameContainer.append(canvas, status, controls);
    draw();
    setTimeout(move, 500);
}

function initPong() {
    const status = createStatus('Use W/S to move');
    const canvas = document.createElement('canvas');
    canvas.width = 600;
    canvas.height = 400;
    canvas.style.background = '#1e293b';
    canvas.style.borderRadius = '12px';
    canvas.style.display = 'block';
    canvas.style.margin = '1rem auto';
    const ctx = canvas.getContext('2d');
    let ball = {x: 300, y: 200, dx: 4, dy: 4};
    let player = {y: 150, score: 0};
    let ai = {y: 150, score: 0};

    function draw() {
        ctx.clearRect(0, 0, 600, 400);
        ctx.fillStyle = '#fff';
        ctx.fillRect(20, player.y, 15, 100);
        ctx.fillRect(565, ai.y, 15, 100);
        ctx.fillRect(ball.x - 10, ball.y - 10, 20, 20);
        ctx.font = '30px Inter';
        ctx.fillText(player.score, 100, 50);
        ctx.fillText(ai.score, 500, 50);
    }

    function update() {
        ball.x += ball.dx;
        ball.y += ball.dy;
        if (ball.y <= 10 || ball.y >= 390) ball.dy = -ball.dy;
        if (ball.x <= 35 && ball.y >= player.y && ball.y <= player.y + 100) ball.dx = -ball.dx;
        if (ball.x >= 550 && ball.y >= ai.y && ball.y <= ai.y + 100) ball.dx = -ball.dx;
        if (ball.x < 0) { ai.score++; ball = {x: 300, y: 200, dx: 4, dy: (Math.random() - 0.5) * 8}; }
        if (ball.x > 600) { player.score++; ball = {x: 300, y: 200, dx: -4, dy: (Math.random() - 0.5) * 8}; }
        ai.y += (ball.y - (ai.y + 50)) * 0.1;
        draw();
        requestAnimationFrame(update);
    }

    document.addEventListener('keydown', e => {
        if (e.key === 'w') player.y = Math.max(0, player.y - 20);
        if (e.key === 's') player.y = Math.min(300, player.y + 20);
    });

    const controls = createControls(() => openGame('pong'));
    gameContainer.append(canvas, status, controls);
    update();
}

function initMemory() {
    const status = createStatus('Find all pairs!');
    const board = createBoard(4, 6, 80);
    const emojis = ['üéÆ','üéØ','üé≤','üé™','üé®','üé≠','üé™','üéØ','üéÆ','üé®','üé≤','üé≠','üé∏','üé∫','üéª','üéπ','üé∏','üé∫','üéª','üéπ','üé¨','üé§'];
    const cards = emojis.sort(() => Math.random() - 0.5).slice(0, 12);
    const values = [...cards, ...cards].sort(() => Math.random() - 0.5);
    let flipped = [], matched = 0;

    for (let i = 0; i < 24; i++) {
        const cell = createCell();
        cell.dataset.value = values[i];
        cell.onclick = () => flip(i);
        board.appendChild(cell);
    }

    const controls = createControls(() => openGame('memory'));
    gameContainer.append(status, board, controls);

    function flip(i) {
        const cell = board.children[i];
        if (cell.classList.contains('flipped') || flipped.length === 2) return;
        cell.textContent = cell.dataset.value;
        cell.classList.add('flipped');
        flipped.push(i);
        if (flipped.length === 2) {
            setTimeout(checkMatch, 800);
        }
    }

    function checkMatch() {
        const [a, b] = flipped;
        if (board.children[a].dataset.value === board.children[b].dataset.value) {
            matched += 2;
            if (matched === 24) status.textContent = 'You win! üéâ';
        } else {
            board.children[a].textContent = '';
            board.children[b].textContent = '';
            board.children[a].classList.remove('flipped');
            board.children[b].classList.remove('flipped');
        }
        flipped = [];
    }
}

function initSudoku() {
    const status = createStatus('Fill the grid!');
    const board = createBoard(9, 9, 50);
    const grid = Array(9).fill().map(() => Array(9).fill(0));
    const solution = JSON.parse(JSON.stringify(grid));

    // Simple puzzle generation (fixed for demo)
    const puzzle = [
        [5,3,0,0,7,0,0,0,0],
        [6,0,0,1,9,5,0,0,0],
        [0,9,8,0,0,0,0,6,0],
        [8,0,0,0,6,0,0,0,3],
        [4,0,0,8,0,3,0,0,1],
        [7,0,0,0,2,0,0,0,6],
        [0,6,0,0,0,0,2,8,0],
        [0,0,0,4,1,9,0,0,5],
        [0,0,0,0,8,0,0,7,9]
    ];
    for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) grid[r][c] = puzzle[r][c];

    for (let r = 0; r < 9; r++) {
        for (let c = 0; c < 9; c++) {
            const cell = createCell();
            cell.dataset.row = r; cell.dataset.col = c;
            if (grid[r][c]) {
                cell.textContent = grid[r][c];
                cell.style.color = '#60a5fa';
                cell.style.fontWeight = 'bold';
            } else {
                cell.contentEditable = true;
                cell.style.cursor = 'text';
                cell.addEventListener('input', () => {
                    const val = cell.textContent.trim();
                    if (val && !/^[1-9]$/.test(val)) cell.textContent = '';
                });
            }
            board.appendChild(cell);
        }
    }

    const controls = createControls(() => openGame('sudoku'));
    const solveBtn = document.createElement('button');
    solveBtn.className = 'btn secondary';
    solveBtn.textContent = 'Solve';
    solveBtn.onclick = () => {
        // Simple solver stub
        alert('Solver coming soon!');
    };
    controls.appendChild(solveBtn);
    gameContainer.append(status, board, controls);
}

/* ============================================= */
/* **UTILS** */
/* ============================================= */
function createStatus(text) {
    const el = document.createElement('div');
    el.className = 'status';
    el.textContent = text;
    return el;
}

function createBoard(rows, cols, size) {
    const board = document.createElement('div');
    board.className = 'board';
    board.style.gridTemplate = `repeat(${rows}, ${size}px)/repeat(${cols}, ${size}px)`;
    return board;
}

function createCell() {
    const cell = document.createElement('div');
    cell.className = 'cell';
    return cell;
}

function createControls(reloadFn) {
    const group = document.createElement('div');
    group.className = 'btn-group';
    const reset = document.createElement('button');
    reset.className = 'btn danger';
    reset.textContent = 'New Game';
    reset.onclick = reloadFn;
    group.appendChild(reset);
    return group;
}
</script>

</body>
</html>
